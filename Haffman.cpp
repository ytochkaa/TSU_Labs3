#include <iostream>
#include <vector>
#include <map>
#include <list>
#include <fstream>

using namespace std;

vector<bool> bitcode; // объявление вектора булевых значений для кодирования
map<char, vector<bool>> mappingtable; // объявление словаря для хранения таблицы кодирования

class Node{

public:
    int a;// целое число
    char c;//символ
    Node *left, *right;// указатели левого и правого потомка

    /// конструктор без параметров
    Node() {
        left = right = NULL; // инициализация указателей
    }

    ///конструктор с двумя переменными
    Node(Node *L, Node *R){
        left = L; //присваивание значение указателю на левого потомка
        right = R; //присваивание значения указателю на правого потомка
        a = L->a + R->a; // сумма значений потомков
    }
};


///структура для сравнения значений
struct MyCompare {
    bool operator()(const Node *l, const Node *r) const { //перегрузка оператора ()
        return l->a < r->a; // сравнение значений потомков
    }
};

/// функция для заполнения словаря таблцей кодирования
void Table(Node *root) {
    if (root->left != NULL){ // левый существет?
        bitcode.push_back(0); // добавляем "0" в вектор кодирования
        Table(root->left); // рекурсия для левого
        bitcode.pop_back(); // удаляем последний элемент из вектора
    }
    if (root->right != NULL){ //правый существет?
        bitcode.push_back(1); //добавляем "1" в вектор кодирования
        Table(root->right); // рекурсия для правого
        bitcode.pop_back(); // удаляем последний элемент из вектора

    }
    if (root->left == NULL && root->right == NULL) { // нет не лвого, ни правого потомка
        mappingtable[root->c] = bitcode; // добавляем в словарь элемент с ключом
        // - символом и значением - вектором кодирования
    }
}
//Данная функция считывает символы из файла "text.txt", кодирует их, используя таблицу соответствия "mappingtable",
// и записывает закодированные данные как бинарные байты в файл "encoded.txt". Когда байт заполняется 8-ю битами,
// он записывается в выходной файл, а временная переменная `buf` сбрасывается для следующего байта.

/// функция для создания закодированного файла
void CreateEncodedFile() {
    
    ifstream f("text.txt", ios::binary); //чтение
    ofstream encodedFile("encoded.txt", ios::binary);// создание файла
    int count = 0; // счётчик битов
    char buf = 0; // переменная для временного хранения байта

    while (!f.eof()) { // // пока не достигнут конец файла

        char c = f.get(); // считываем символы
        vector<bool> x = mappingtable[c]; // получаем кодировку символа из словаря

        for (int n = 0; n < x.size(); n++) { // для каждого бита кодировки символа
            buf = buf | x[n] << (7 - count); // записываем бит в байт
            count++;// увеличиваем счетчик битов
            if (count == 8) {// если счетчик равен 8
                count = 0;// обнуляем счетчик
                encodedFile.write((char*)& buf, sizeof(buf));// записываем байт в файл
                buf = 0;// обнуляем временную переменную
            }
        }
    }

    f.close();//закрываем файл для чтения
    encodedFile.close();// закрываем файл для записи

}

//Этот фрагмент кода отвечает за создание закодированного файла на основе данных, считанных из файла "text.txt".

//Сначала открывается файл "text.txt" для чтения в бинарном режиме,
// а также создается файл "encoded.txt" для записи в бинарном режиме.
// Затем инициализируются переменные count и buf для отслеживания битов.

//Далее происходит итерация по содержимому файла "text.txt" с помощью цикла while,
// пока не будет достигнут конец файла.
// Для каждого символа c из файла "text.txt" получается его кодировка
// в виде последовательности битов с помощью словаря mappingtablec.

//Затем происходит итерация по каждому биту кодировки символа.
// Каждый бит записывается в переменную buf с использованием логической операции OR
// и сдвига на соответствующее количество битов влево.
// При достижении 8 битов происходит запись байта в файл "encoded.txt" с помощью метода write,
// а затем переменная buf обнуляется.

//Когда все символы из файла "text.txt" закодированы и записаны в файл "encoded.txt", оба файла закрываются.

//Таким образом, этот код выполняет процесс кодирования содержимого файла "text.txt"
// с использованием предварительно заданной таблицы кодировки
// и записывает закодированные данные в файл "encoded.txt".

/// функция для создания раскодированного файла
void CreateDecodedFile(Node* root) {

    ifstream encodedFile("encoded.txt", ios::binary); // открытие файла для чтения
    ofstream decodedFile("decoded.txt", ios::binary); // создание файла для записи

    Node *p = root; // указатель на корневой узел
    int count = 0; // счетчик битов
    char byte; // переменная для чтения байта из файла
    byte = encodedFile.get(); // считываем первый байт из файла

    ///!
    while (!encodedFile.eof()) { // пока не достигнут конец файла

        bool b = byte & (1 << (7 - count)); // проверяем бит в байте

        if (b) { // если бит равен 1
            p = p->right; // переходим к правому потомку
        } else { // если бит равен 0
            p = p->left; // переходим к левому потомку
        }

        if (p->left == nullptr && p->right == nullptr) { // если достигнут листовой узел
            if (p != nullptr && p->left == nullptr && p->right == nullptr) { // если узел не пустой
                decodedFile << p->c; // записываем символ в файл
                p = root; // переходим к корневому узлу
            }
        }

        count++; // увеличиваем счетчик битов

        if (count == 8) { // если счетчик равен 8
            count = 0; // обнуляем счетчик
            byte = encodedFile.get(); // считываем следующий байт из файла
        }
    }

    encodedFile.close(); // закрываем файл для чтения
    decodedFile.close(); // закрываем файл для записи
}
// Этот фрагмент кода отвечает за создание закодированного файла на основе данных, считанных из файла "text.txt".
//
// Сначала открывается файл "text.txt" для чтения в бинарном режиме,
// а также создается файл "encoded.txt" для записи в бинарном режиме.
// Затем инициализируются переменные count и buf для отслеживания битов.
///!
// Далее происходит итерация по содержимому файла "text.txt" с помощью цикла while,
// пока не будет достигнут конец файла. Для каждого символа c из файла "text.txt"
// получается его кодировка в виде последовательности битов с помощью словаря mappingtablec.
//
// Затем происходит итерация по каждому биту кодировки символа.
// Каждый бит записывается в переменную buf с использованием логической операции OR
// и сдвига на соответствующее количество битов влево.
// При достижении 8 битов происходит запись байта в файл "encoded.txt"
// с помощью метода write, а затем переменная buf обнуляется.
//
// Когда все символы из файла "text.txt" закодированы и записаны в файл "encoded.txt", оба файла закрываются.
//
// Таким образом, этот код выполняет процесс кодирования содержимого файла "text.txt"
// с использованием предварительно заданной таблицы кодировки и записывает закодированные данные в файл "encoded.txt".

int main(int argc, char *argv[]){

    ifstream f("text.txt", ios::binary); // открытие файла для чтения
    map <char, int> m; // объявление словаря для подсчета частоты символов

    while (!f.eof()){ // пока не достигнут конец файла
        char c = f.get(); // считываем символ из файла
        m[c]++; // увеличиваем значение частоты символа в словаре
    }
    list<Node *> t; // объявление списка указателей на узлы
    for (map<char, int>::iterator itr = m.begin(); itr != m.end(); ++itr){ // для каждого элемента в словаре
        Node *p = new Node; // создаем новый узел
        p->c = itr->first; // присваиваем узлу символ
        p->a = itr->second; // присваиваем узлу частоту символа
        t.push_back(p); // добавляем узел в список
    }

    while (t.size() != 1){ // пока список не содержит только один узел
        t.sort(MyCompare()); // сортируем список по возрастанию частоты
        Node *Lchild = t.front(); // получаем указатель на первый узел в списке
        t.pop_front(); // удаляем первый узел из списка
        Node *Rchild = t.front(); // получаем указатель на следующий узел в списке
        t.pop_front(); // удаляем следующий узел из списка
        Node *parent = new Node(Lchild, Rchild); // создаем новый узел с потомками
        t.push_back(parent); // добавляем новый узел в список
    }

    Node *root = t.front(); // получаем указатель на корневой узел

    Table(root); // вызываем функцию для заполнения таблицы кодирования
    CreateEncodedFile(); // вызываем функцию для создания закодированного файла
    CreateDecodedFile(root); // вызываем функцию для создания раскодированного файла

    return 0; // возвращаем успешное завершение программы
}